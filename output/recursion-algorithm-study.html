<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>"Recursion - Algorithm Study" - arvimal.github.io</title>
    <meta charset="utf-8" />
    <link href="http://fonts.googleapis.com/css?family=Arimo:400,700|Inika" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" type="text/css" href="https://arvimal.github.io/theme/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="https://arvimal.github.io/theme/pastie.css" />
    <link href="https://arvimal.github.io/" type="application/atom+xml" rel="alternate" title="arvimal.github.io Atom Feed" />


  </head>

  <body>
    <div class="container">
      <div class="row">
        <div class="span8">
<div id="content">
    <div class="header">
        <h1>"Recursion - Algorithm Study"</h1>
    </div>
    <p class="meta"><small><span><a href="https://arvimal.github.io/author/vimal-ar/">Vimal A.R</a> - </span><span>June 27, 2017</span> - <span class="tags"></span></small></p>
        <div class="entry-content">
        <ul>
<li>"data-structures-and-algorithms"</li>
<li>"programming"</li>
<li>"python"
tags:</li>
<li>"algorithms"</li>
<li>"programming"</li>
<li>"python"</li>
<li>"recursion"</li>
</ul>
<hr>
<p>_<strong>R</strong>_ecursion is a technique by which a function calls itself until a condition is met.</p>
<h2>Introduction</h2>
<p>Loops or repetitive execution based on certain conditions are inevitable in programs. Usual loops include <code>if</code>, <code>while</code> and <code>for</code> loops. <code>Recursion</code> is an entirely different way to deal with such situations, and in many cases, easier.</p>
<p><code>Recursion</code> is a when a function calls itself in each iteration till a condition is met. Ideally, the data set in each iteration gets smaller until it reach the required condition, after which the recursive function exists.</p>
<p>A typical example of recursion is a <code>factorial</code> function.</p>
<h2>How does Recursion work?</h2>
<p>A <code>recursive</code> function ideally contains a <code>Base</code> case and a <code>Recursive</code> case.</p>
<p>A <code>Recursive</code> case is when the function calls itself, until the <code>Base</code> case is met. Each level of iteration in the <code>Recursive</code> case moves the control to the next level.</p>
<p>Once a specific level finishes execution, the control is passed back to the previous level of execution. A <code>Recursive</code> function can go several layers deep until the <code>Base</code> condition is met. In short, a <code>Recursive</code> case is a loop in which the function calls itself.</p>
<p>The <code>Base</code> case is required so that the function doesn't continue running in the <code>Recursive</code> loop forever. Once the <code>Base</code> case is met, the control moves out of the <code>Recursive</code> case, executes the conditions in the <code>Base</code> case (if any), and exits.</p>
<p>As mentioned in the <code>Introduction</code>, a factorial function can be seen as an example of recursion.</p>
<h3>NOTE:</h3>
<p>The <code>Base</code> case for a factorial function is when <code>n == 1</code></p>
<p>Consider <code>n!</code>:</p>
<p><code>n!</code> can be written as:</p>
<p><strong>n x (n - 1) x (n - 2) x (n - 3) x .... x 1</strong></p>
<p><code>n!</code> can also be represented as:</p>
<p>[code language="bash"] n! = n * (n - 1)! ---&gt; [Step 1] (n - 1)! = (n - 1) * (n - 2)! ---&gt; [Step 2] (n - 2)! = (n - 2) * (n - 3)! ---&gt; [Step 3] . .. ... (n - (n - 1)) = 1 ---&gt; [Base case] [/code]</p>
<p>Each level/step is a product of a value and all the levels below it. Hence, <code>Step 1</code> will end up moving to <code>Step 2</code> to get the factorial of elements below it, then to <code>Step 3</code> and so on.</p>
<p>ie.. the control of execution move as:</p>
<p><strong>[Step 1] -&gt; [Step 2] -&gt; [Step 3] -&gt; ..... [Step n]</strong></p>
<p>In a much easier-to-grasp example, a <code>5!</code> would be:</p>
<p>[code language="bash"] 5! = 5 * 4! ---&gt; [Step 1] 4! = 4 * 3! ---&gt; [Step 2] 3! = 3 * 2! ---&gt; [Step 3] 2! = 2 * 1! ---&gt; [Step 4] 1! = 1 ---&gt; [Step 5] / [Base case] [/code]</p>
<p>The order of execution will be :</p>
<p><strong>[Step 1] -&gt; [Step 2] -&gt; [Step 3] -&gt; [Step 4] -&gt; [Step 5]</strong></p>
<p>As we know, in <code>Recursion</code>, each layer pause itself and pass the control to the next level. Once it reach the end or the <code>Base</code> case, it returns the result back to the previous level one by one until it reaches where it started off.</p>
<p>In this example, once the control of execution reaches <code>Step 5 / Base case</code> ,  the control is returned back to its previous level <code>Step 4</code> . This level returns the result back to <code>Step 3</code> which completes its execution and returns to <code>Step 2</code> , so on and so forth until it reach  <code>Step 1</code> .</p>
<p>The return control flow would be as:</p>
<p><strong>[Base case / Step 5] -&gt; [Step 4] -&gt; [Step 3] -&gt; [Step 2] -&gt; [Step 1] -&gt; Result.</strong></p>
<p>This can be summed up using an awesome pictorial representation, from the book <code>Grokking Algorithms</code> by Adit. Please check out the <code>References</code> section for the link for more information about this awesome book.</p>
<p><img alt="factorial_recursion" src="images/factorial_recursion.png"></p>
<p><em>Figure 1: Recursion, Recursive case and Base case (Copyright Manning Publications, drawn by adit.io)</em></p>
<h2>Code</h2>
<h3>Example 1:</h3>
<ul>
<li>A <code>factorial</code> function in a <code>while</code> loop</li>
</ul>
<p>[code language="python"] def fact(n): factorial = 1 while n &gt; 1: factorial = factorial * n n = n - 1 return factorial</p>
<p>print("Factorial of {0} is {1}".format(10, fact(10))) print("Factorial of {0} is {1}".format(20, fact(20))) [/code]</p>
<ul>
<li>The same function above, in a <code>recursive</code> loop</li>
</ul>
<p>[code language="python"] def factorial(n): if n == 0: return 1 else: return n * factorial(n - 1)</p>
<p>print("Factorial of {0} is {1}".format(10, factorial(10))) print("Factorial of {0} is {1}".format(20, factorial(20))) [/code]</p>
<h3>Example 2:</h3>
<ul>
<li>A function to sum numbers in a normal <code>for</code> loop.</li>
</ul>
<p>[code language="python"] def my_sum(my_list): num = 0 for i in my_list: num += i return num</p>
<p>print(my_sum([10, 23, 14, 12, 11, 94, 20])) [/code]</p>
<ul>
<li>The same function to add numbers, in a <code>recursive</code> loop</li>
</ul>
<p>[code language="python"] def my_sum(my_list): if my_list == []: return 0 else: return my_list[0] + my_sum(my_list[1:])</p>
<p>print(my_sum([10, 23, 14, 12, 11, 94, 20])) [/code]</p>
<h2>Code explanation</h2>
<p>Both <code>Example 1</code> and <code>Example 2</code> are represented as an iterative function as well as a recursive function.</p>
<p>The iterative function calls the <code>next()</code> function on the iterator <code>sum.__iter__()</code> magic method iterate over the entire data set. The recursive function calls itself to reach a base case and return the result.</p>
<h2>Observations:</h2>
<p>While a recursive function does not necessarily give you an edge on performance, it is much easier to understand and the code is cleaner.</p>
<p>Recursion has a disadvantage though, for large data sets. Each loop is put on a call stack until it reaches a <code>Base</code> case. Once the <code>Base</code> case is met, the call stack is rewound back to reach where it started, executing each of the previous levels on the way. The examples above showed a <code>sum</code> function and a <code>factorial</code> function. In large data sets, this can lead to a large call stack which in turns take a lot of memory.</p>
<h2>References:</h2>
<ol>
<li><a href="http://www.amazon.in/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486811444&amp;sr=1-1&amp;keywords=grokking+algorithms">Grokking Algorithms</a></li>
<li><a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/812656217X/ref=sr_1_1?ie=UTF8&amp;qid=1487126103&amp;sr=8-1&amp;keywords=data+structures+and+algorithms+in+python">Data Structures and Algorithms in Python</a></li>
</ol>
        </div><!-- /.entry-content -->
</div>
        </div>
        <div class="span3 offset1">
          <div class="well">
            <ul class="nav nav-list">
              <li class="nav-header">Blog</li>
              <li ><a href="https://arvimal.github.io">Index</a></li>
              <li ><a href="https://arvimal.github.io/tags/">Tags</a></li>
              <li ><a href="https://arvimal.github.io/archives/">Archiv</a></li>
              <li class="nav-header">Anderes</li>
              <li><a href="/archives.html">Archives</a></li>
              <li><a href="/categories.html">Categories</a></li>
              <li><a href="/tags.html">Tags</a></li>
            </ul>
          </div><!-- /#menu -->
        </div>
      </div>

      <hr />

      <div class="row">
        <div class="span12">
          <div id="about">
            <p>Proudly powered by <a href="http://twitter.github.com/bootstrap/">bootstrap</a>, <a href="http://docs.notmyidea.org/alexis/pelican/">pelican</a>, <a href="http://python.org">python</a> and <a href="http://www.julo.ch/about/">Alex</a>!</p>
          </div><!-- /#about -->
        </div><!-- /#contentinfo -->
      </div>
    </div>


  </body>
</html>