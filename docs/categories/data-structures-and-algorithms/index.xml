<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>data-structures-and-algorithms - Category - The Child is Father of the Man</title>
        <link>https://arvimal.github.io/categories/data-structures-and-algorithms/</link>
        <description>data-structures-and-algorithms - Category - The Child is Father of the Man</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 27 Jun 2017 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://arvimal.github.io/categories/data-structures-and-algorithms/" rel="self" type="application/rss+xml" /><item>
    <title>Recursion - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/06/2017-06-27-recursion-algorithm-study/</link>
    <pubDate>Tue, 27 Jun 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/06/2017-06-27-recursion-algorithm-study/</guid>
    <description><![CDATA[_R_ecursion is a technique by which a function calls itself until a condition is met.
Introduction Loops or repetitive execution based on certain conditions are inevitable in programs. Usual loops include if, while and for loops. Recursion is an entirely different way to deal with such situations, and in many cases, easier.
Recursion is a when a function calls itself in each iteration till a condition is met. Ideally, the data set in each iteration gets smaller until it reach the required condition, after which the recursive function exists.]]></description>
</item><item>
    <title>Selection Sort - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/02/2017-02-11-selection-sort-algorithm-study/</link>
    <pubDate>Sat, 11 Feb 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/02/2017-02-11-selection-sort-algorithm-study/</guid>
    <description><![CDATA[_S_election Sort is a sorting algorithm used to sort a data set either in incremental or decremental order.
It goes through the entire elements one by one and hence it&rsquo;s not a very efficient algorithm to work on large data sets.
How does Selection sort work? Selection sort starts with an unsorted data set. With each iteration, it builds up a sub dataset with the sorted data.
By the end of the sorting process, the sub dataset contains the entire elements in a sorted order.]]></description>
</item><item>
    <title>Binary Search - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/01/2017-01-16-binary-search-algorithm-study/</link>
    <pubDate>Mon, 16 Jan 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/01/2017-01-16-binary-search-algorithm-study/</guid>
    <description><![CDATA[Introduction **B**inary Search is a search method used to find an object in a data set. This is much faster compared to the Linear Search algorithm we saw in a previous post.
This algorithm works on the Divide and Conquer principle. Binary Search gets its speed by essentially dividing the list/array in half in each iteration, thus reducing the dataset size for the next iteration.
Imagine searching for an element in a rather large dataset.]]></description>
</item><item>
    <title>Linear Search - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/01/2017-01-15-linear-search-algorithm-study/</link>
    <pubDate>Sun, 15 Jan 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/01/2017-01-15-linear-search-algorithm-study/</guid>
    <description><![CDATA[Introduction _L_inear Search is an way to search a data set for an element of interest. It is one of the many search algorithms available and is also the most direct and simple of the lot.
Linear search looks for the element of interest in a dataset starting from the first element and moves on to the consecutive elements till it finds the one we&rsquo;re interested in. Due to this behaviour, it&rsquo;s not the fastest search algorithm around.]]></description>
</item><item>
    <title>Code complexity - The Big O notation [O(n)]</title>
    <link>https://arvimal.github.io/posts/2016/05/2016-05-08-big-o-notation-on/</link>
    <pubDate>Sun, 08 May 2016 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2016/05/2016-05-08-big-o-notation-on/</guid>
    <description><![CDATA[Efficiency or Complexity is how well you&rsquo;re using your resources to get your code run.
Efficiency can be calculated on the basis of how much time your code takes to run/execute.
Understanding the efficiency of your code can help to reduce the complexity, thus improving the runtime efficiency further. Getting the same job done in less time and less system resources is always good.
Once you find the efficiency of your program, you can start to find ways for:]]></description>
</item><item>
    <title>Data Structures - Arrays</title>
    <link>https://arvimal.github.io/posts/2016/05/2016-05-08-data-structures-arrays/</link>
    <pubDate>Sun, 08 May 2016 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2016/05/2016-05-08-data-structures-arrays/</guid>
    <description><![CDATA[Arrays are a commonly used data structure, and is one of the first a DS student looks into.
It is created as a collection of memory addresses which are contiguous in memory. These memory locations store data of a specific type depending on the array&rsquo;s type.
Advantages:
 Arrays are easier to create since the size and type is mentioned at the creation time. Arrays have constant access/lookup time since the lookup is done by accessing the memory location as an offset from the base/first element.]]></description>
</item></channel>
</rss>
