<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on The Child is Father of the Man</title>
    <link>https://arvimal.github.io/categories/python/</link>
    <description>Recent content in python on The Child is Father of the Man</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Aug 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://arvimal.github.io/categories/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Callables in Python</title>
      <link>https://arvimal.github.io/posts/2017/08/2017-08-09-callables-in-python/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2017/08/2017-08-09-callables-in-python/</guid>
      <description>Introduction A callable is an object in Python that can be called / executed when called with parantheses ( ). Classes and functions are callable.
Callables can be a class, a function, or an instance of a class. In simple terms, a class/function/instance/builtin is callable if it gets executed while being called with the parantheses ().
Example 1: [code language=&amp;ldquo;bash&amp;rdquo;]
In [1]: help() Welcome to Python 3.6&amp;rsquo;s help utility! &amp;ndash; content omitted &amp;ndash; &amp;mdash;&amp;mdash;&amp;ndash; In [2]: int() Out[2]: 0</description>
    </item>
    
    <item>
      <title>Recursion - Algorithm Study</title>
      <link>https://arvimal.github.io/posts/2017/06/2017-06-27-recursion-algorithm-study/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2017/06/2017-06-27-recursion-algorithm-study/</guid>
      <description>_R_ecursion is a technique by which a function calls itself until a condition is met.
Introduction Loops or repetitive execution based on certain conditions are inevitable in programs. Usual loops include if, while and for loops. Recursion is an entirely different way to deal with such situations, and in many cases, easier.
Recursion is a when a function calls itself in each iteration till a condition is met. Ideally, the data set in each iteration gets smaller until it reach the required condition, after which the recursive function exists.</description>
    </item>
    
    <item>
      <title>Selection Sort - Algorithm Study</title>
      <link>https://arvimal.github.io/posts/2017/02/2017-02-11-selection-sort-algorithm-study/</link>
      <pubDate>Sat, 11 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2017/02/2017-02-11-selection-sort-algorithm-study/</guid>
      <description>_S_election Sort is a sorting algorithm used to sort a data set either in incremental or decremental order.
It goes through the entire elements one by one and hence it&amp;rsquo;s not a very efficient algorithm to work on large data sets.
How does Selection sort work? Selection sort starts with an unsorted data set. With each iteration, it builds up a sub dataset with the sorted data.
By the end of the sorting process, the sub dataset contains the entire elements in a sorted order.</description>
    </item>
    
    <item>
      <title>Binary Search - Algorithm Study</title>
      <link>https://arvimal.github.io/posts/2017/01/2017-01-16-binary-search-algorithm-study/</link>
      <pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2017/01/2017-01-16-binary-search-algorithm-study/</guid>
      <description>Introduction **B**inary Search is a search method used to find an object in a data set. This is much faster compared to the Linear Search algorithm we saw in a previous post.
This algorithm works on the Divide and Conquer principle. Binary Search gets its speed by essentially dividing the list/array in half in each iteration, thus reducing the dataset size for the next iteration.
Imagine searching for an element in a rather large dataset.</description>
    </item>
    
    <item>
      <title>Linear Search - Algorithm Study</title>
      <link>https://arvimal.github.io/posts/2017/01/2017-01-15-linear-search-algorithm-study/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2017/01/2017-01-15-linear-search-algorithm-study/</guid>
      <description>Introduction _L_inear Search is an way to search a data set for an element of interest. It is one of the many search algorithms available and is also the most direct and simple of the lot.
Linear search looks for the element of interest in a dataset starting from the first element and moves on to the consecutive elements till it finds the one we&amp;rsquo;re interested in. Due to this behaviour, it&amp;rsquo;s not the fastest search algorithm around.</description>
    </item>
    
    <item>
      <title>Accessor and Mutator methods - Python</title>
      <link>https://arvimal.github.io/posts/2016/12/2016-12-18-accessor-and-mutator-methods-python/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/12/2016-12-18-accessor-and-mutator-methods-python/</guid>
      <description>A method defined within a class can either be an Accessor or a Mutator method.
An Accessor method returns the information about the object, but do not change the state or the object.
A Mutator method, also called an Update method, can change the state of the object.
Consider the following example:
[code language=&amp;ldquo;python&amp;rdquo;] In [10]: a = [1,2,3,4,5]
In [11]: a.count(1) Out[11]: 1
In [12]: a.index(2) Out[12]: 1
In [13]: a Out[13]: [1, 2, 3, 4, 5]</description>
    </item>
    
    <item>
      <title>Python, Objects, and some more..</title>
      <link>https://arvimal.github.io/posts/2016/10/2016-10-20-python-objects-and-some-more/</link>
      <pubDate>Thu, 20 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/10/2016-10-20-python-objects-and-some-more/</guid>
      <description>_E_verything in Python is an object, what does that mean? This post tries to discuss some very basic concepts.
What does the following assignment do?
[code language=&amp;ldquo;python&amp;rdquo;]
a = 1 [/code] Of course, anyone dabbled in code knows this. The statement above creates a container `a` and stores the value `1` in it.
But it seem that&amp;rsquo;s not exactly what&amp;rsquo;s happening, at least from Python&amp;rsquo;s view-point.
When a = 1 is entered or executed by the python interpreter, the following happens in the backend, seemingly unknown to the user.</description>
    </item>
    
    <item>
      <title>Inheritance and super() - Object Oriented Programming</title>
      <link>https://arvimal.github.io/posts/2016/07/2016-07-01-inheritance-and-super-object-oriented-programming/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/07/2016-07-01-inheritance-and-super-object-oriented-programming/</guid>
      <description>_s_uper() is a feature through which inherited methods can be accessed, which has been overridden in a class. It can also help with the MRO lookup order in case of multiple inheritance. This may not be obvious first, but a few examples should help to drive the point home.
Inheritance and method overloading was discussed in a previous post, where we saw how inherited methods can be overloaded or enhanced in the child classes.</description>
    </item>
    
    <item>
      <title>Inheritance and Method overloading - Object Oriented Programming</title>
      <link>https://arvimal.github.io/posts/2016/06/2016-06-29-inheritance-and-method-overloading-object-oriented-programming/</link>
      <pubDate>Wed, 29 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/06/2016-06-29-inheritance-and-method-overloading-object-oriented-programming/</guid>
      <description>_I_nheritance is a usual theme in Object Oriented Programming. Because of Inheritance, the functions/methods defined in parent classes can be called in Child classes which enables code reuse, and several other features. In this article, we try to understand some of those features that come up with Inheritance.
We&amp;rsquo;ve discussed Abstract Methods in an earlier post, which is a feature part of Inheritance, and can be applied on child classes that inherits from a Parent class.</description>
    </item>
    
    <item>
      <title>Abstract Base Classes/Methods - Object Oriented Programming</title>
      <link>https://arvimal.github.io/posts/2016/06/2016-06-14-abstract-base-classesmethods-object-oriented-programming/</link>
      <pubDate>Tue, 14 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/06/2016-06-14-abstract-base-classesmethods-object-oriented-programming/</guid>
      <description>_A_bstract classes, in short, are classes that are supposed to be inherited or subclassed, rather than instantiated.
Through Abstract Classes, we can enforce a blueprint on the subclasses that inherit the Abstract Class. This means that Abstract classes can be used to define a set of methods that must be implemented by it subclasses.
Abstract classes are used when working on large projects where classes have to be inherited, and need to strictly follow certain blueprints.</description>
    </item>
    
    <item>
      <title>`self` in Python - Object Oriented Programming</title>
      <link>https://arvimal.github.io/posts/2016/06/2016-06-12-self-in-python/</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/06/2016-06-12-self-in-python/</guid>
      <description>_T_his article was long overdue and should have been published before many of the articles in this blog. Better late than never.
self in Python is usually used in an Object Oriented nomenclature, to denote the instance/object created from a Class.
In short, self is the instance itself.
Let&amp;rsquo;s check the following example:
[code language=&amp;ldquo;python&amp;rdquo;] class MyClass(object): def __init__(self, name): self.name = name print(&amp;ldquo;Initiating the instance!&amp;quot;)
def hello(self): print(self.name)
myclass = MyClass(&amp;ldquo;Dan Inosanto&amp;rdquo;)</description>
    </item>
    
    <item>
      <title>Instance, Class, and Static methods - Object Oriented Programming</title>
      <link>https://arvimal.github.io/posts/2016/06/2016-06-12-instance-class-static-methods-object-oriented-programming/</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/06/2016-06-12-instance-class-static-methods-object-oriented-programming/</guid>
      <description>_F_unctions defined under a class are also called methods. Most of the methods are accessed through an instance of the class.
There are three types of methods:
 Instance methods Static methods Class methods  Both Static methods and Class methods can be called using the @staticmethod and @classmethod syntactic sugar respectively.
Instance methods _I_nstance methods are also called Bound methods since the instance is bound to the class via self.</description>
    </item>
    
    <item>
      <title>Magic methods and Syntactic sugar in Python</title>
      <link>https://arvimal.github.io/posts/2016/06/2016-06-02-magic-methods-in-python/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/06/2016-06-02-magic-methods-in-python/</guid>
      <description>Magic methods _M_agic methods are special methods which can be defined (or already designed and available) to act on objects.
Magic methods start and end with underscores &amp;quot;__&amp;quot;, and are not implicitly called by the user even though they can be. Most magic methods are used as syntactic sugar by binding it to more clear/easy_to_understand keywords.
Python is mostly objects and method calls done on objects. Many available functions in Python are actually tied to magic methods_**.</description>
    </item>
    
    <item>
      <title>Decorators - Object Oriented Programming</title>
      <link>https://arvimal.github.io/posts/2016/05/2016-05-30-decorators-object-oriented-programming/</link>
      <pubDate>Mon, 30 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/05/2016-05-30-decorators-object-oriented-programming/</guid>
      <description>_D_ecorators are wrapper functions (or classes) that wrap and modify another function (or class), and change it&amp;rsquo;s behavior as required. Decorators help to modify your code without actually modifying the working function/class itself.
There are several inbuilt Decorators in Python, such as @classmethod and @staticmethod. Examples on these are due for another post.
Decorators are called to act upon a function or class, by mentioning the Decorator name just above the function/class.</description>
    </item>
    
    <item>
      <title>Method Resolution Order - Object Oriented Programming</title>
      <link>https://arvimal.github.io/posts/2016/05/2016-05-30-method-resolution-order-object-oriented-programming/</link>
      <pubDate>Mon, 30 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/05/2016-05-30-method-resolution-order-object-oriented-programming/</guid>
      <description>_M_ethod Resolution Order or &amp;lsquo;MRO&amp;rsquo; in short, denotes the way a programming language resolves a method or attribute. This post looks into how Method Resolution Order works, using Python.
Python supports classes inheriting from other classes. The class being inherited is called the Parent/Super class, while the class that inherits is called the Child/Sub class.
While inheriting from another class, the interpreter needs a way to resolve the methods that are being called via an instance.</description>
    </item>
    
    <item>
      <title>`ceph-check` - A Ceph installation checker</title>
      <link>https://arvimal.github.io/posts/2016/05/2016-05-08-ceph-check-a-ceph-installation-checker/</link>
      <pubDate>Sun, 08 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2016/05/2016-05-08-ceph-check-a-ceph-installation-checker/</guid>
      <description>Many a user wants to know if a Ceph cluster installation has been done to a specific suggested guideline.
Technologies like RAID is better avoided in Ceph due to an additional layer, which Ceph already takes care of.
I&amp;rsquo;ve started writing a tool which can be run from the Admin node, and it aims to check various such points.
The code can be seen at https://github.com/arvimal/ceph_check
The work is slow, really slow, due to my daily work, procrastination, and what not, even though I intend to finish this fast.</description>
    </item>
    
    <item>
      <title>range() and enumerate()</title>
      <link>https://arvimal.github.io/posts/2015/10/2015-10-12-range-and-enumerate-2/</link>
      <pubDate>Mon, 12 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2015/10/2015-10-12-range-and-enumerate-2/</guid>
      <description>The usual way to iterate over a range of numbers or a list in python, is to use range().
Example 0:
[code language=&amp;ldquo;python&amp;rdquo;] colors = [&amp;ldquo;yellow&amp;rdquo;, &amp;ldquo;red&amp;rdquo;, &amp;ldquo;blue&amp;rdquo;, &amp;ldquo;white&amp;rdquo;, &amp;ldquo;black&amp;rdquo;]
for i in range(len(colors)): print(i, colors[i]) [/code]
This should output:
[code language=&amp;ldquo;bash&amp;rdquo;] (0, &amp;lsquo;yellow&amp;rsquo;) (1, &amp;lsquo;red&amp;rsquo;) (2, &amp;lsquo;blue&amp;rsquo;) (3, &amp;lsquo;white&amp;rsquo;) (4, &amp;lsquo;black&amp;rsquo;) [/code]
print(), by default, returns a tuple. If we want to print it in a more presentable way, we’ll need to find the indice at which each value is, and print that as well.</description>
    </item>
    
    <item>
      <title>Calculate a PG id from the hex values in Ceph OSD debug logs</title>
      <link>https://arvimal.github.io/posts/2015/08/2015-08-30-calculate-a-pg-id-from-the-ceph-osd-debug-logs/</link>
      <pubDate>Sun, 30 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://arvimal.github.io/posts/2015/08/2015-08-30-calculate-a-pg-id-from-the-ceph-osd-debug-logs/</guid>
      <description>Recently, I had an incident where the OSDs were crashing at the time of startup. Obviously, the next step was to enable debug logs for the OSDs and understand where they were crashing.
Enabled OSD debug logs dynamically by injecting it with:
 # ceph tell osd.* injectargs &amp;ndash;debug-osd 20 &amp;ndash;debug-ms 1
 NOTE: This command can be run from the MON nodes.
Once this was done, the OSDs were started manually (since it were crashing and not running) and watched out for the next crash.</description>
    </item>
    
  </channel>
</rss>
