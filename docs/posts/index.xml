<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - The Child is Father of the Man</title>
        <link>https://arvimal.github.io/posts/</link>
        <description>All Posts | The Child is Father of the Man</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 09 Aug 2017 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://arvimal.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Callables in Python</title>
    <link>https://arvimal.github.io/posts/2017/08/2017-08-09-callables-in-python/</link>
    <pubDate>Wed, 09 Aug 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/08/2017-08-09-callables-in-python/</guid>
    <description><![CDATA[Introduction A callable is an object in Python that can be called / executed when called with parantheses ( ). Classes and functions are callable.
Callables can be a class, a function, or an instance of a class. In simple terms, a class/function/instance/builtin is callable if it gets executed when called with parantheses ().
Example 1: In [1]: help() Welcome to Python 3.6&#39;s help utility!  -- content omitted -- -------- In [2]: int() Out[2]: 0 In [3]: callable(int) Out [3]: True In [4]: callable(help) Out [4]: True In [5]: def hello(): print(&#34;Howdy!]]></description>
</item><item>
    <title>Writing a minimalistic kernel module in Linux - Part 1</title>
    <link>https://arvimal.github.io/posts/2017/07/2017-07-27-writing-a-minimalistic-kernel-module-in-linux-part-1/</link>
    <pubDate>Thu, 27 Jul 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/07/2017-07-27-writing-a-minimalistic-kernel-module-in-linux-part-1/</guid>
    <description><![CDATA[Introduction _L_oadable Kernel Modules (LKM) are object code that can be loaded into memory, often used for supporting hardware or enable specific features. Kernel modules enable the core kernel to be minimal and have features to be loaded as required.
A kernel module is a normal file usually suffixed with .ko denoting it&rsquo;s a kernel object file. It contains compiled code from one or more source files, gets linked to the kernel when loaded, and runs in kernel space.]]></description>
</item><item>
    <title>Recursion - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/06/2017-06-27-recursion-algorithm-study/</link>
    <pubDate>Tue, 27 Jun 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/06/2017-06-27-recursion-algorithm-study/</guid>
    <description><![CDATA[_R_ecursion is a technique by which a function calls itself until a condition is met.
Introduction Loops or repetitive execution based on certain conditions are inevitable in programs. Usual loops include if, while and for loops. Recursion is an entirely different way to deal with such situations, and in many cases, easier.
Recursion is a when a function calls itself in each iteration till a condition is met. Ideally, the data set in each iteration gets smaller until it reach the required condition, after which the recursive function exists.]]></description>
</item><item>
    <title>Selection Sort - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/02/2017-02-11-selection-sort-algorithm-study/</link>
    <pubDate>Sat, 11 Feb 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/02/2017-02-11-selection-sort-algorithm-study/</guid>
    <description><![CDATA[_S_election Sort is a sorting algorithm used to sort a data set either in incremental or decremental order.
It goes through the entire elements one by one and hence it&rsquo;s not a very efficient algorithm to work on large data sets.
How does Selection sort work? Selection sort starts with an unsorted data set. With each iteration, it builds up a sub dataset with the sorted data.
By the end of the sorting process, the sub dataset contains the entire elements in a sorted order.]]></description>
</item><item>
    <title>Binary Search - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/01/2017-01-16-binary-search-algorithm-study/</link>
    <pubDate>Mon, 16 Jan 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/01/2017-01-16-binary-search-algorithm-study/</guid>
    <description><![CDATA[Introduction **B**inary Search is a search method used to find an object in a data set. This is much faster compared to the Linear Search algorithm we saw in a previous post.
This algorithm works on the Divide and Conquer principle. Binary Search gets its speed by essentially dividing the list/array in half in each iteration, thus reducing the dataset size for the next iteration.
Imagine searching for an element in a rather large dataset.]]></description>
</item><item>
    <title>Linear Search - Algorithm Study</title>
    <link>https://arvimal.github.io/posts/2017/01/2017-01-15-linear-search-algorithm-study/</link>
    <pubDate>Sun, 15 Jan 2017 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2017/01/2017-01-15-linear-search-algorithm-study/</guid>
    <description><![CDATA[Introduction _L_inear Search is an way to search a data set for an element of interest. It is one of the many search algorithms available and is also the most direct and simple of the lot.
Linear search looks for the element of interest in a dataset starting from the first element and moves on to the consecutive elements till it finds the one we&rsquo;re interested in. Due to this behaviour, it&rsquo;s not the fastest search algorithm around.]]></description>
</item><item>
    <title>Accessor and Mutator methods - Python</title>
    <link>https://arvimal.github.io/posts/2016/12/2016-12-18-accessor-and-mutator-methods-python/</link>
    <pubDate>Sun, 18 Dec 2016 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2016/12/2016-12-18-accessor-and-mutator-methods-python/</guid>
    <description><![CDATA[A method defined within a class can either be an Accessor or a Mutator method.
An Accessor method returns the information about the object, but do not change the state or the object.
A Mutator method, also called an Update method, can change the state of the object.
Consider the following example:
[code language=&ldquo;python&rdquo;] In [10]: a = [1,2,3,4,5]
In [11]: a.count(1) Out[11]: 1
In [12]: a.index(2) Out[12]: 1
In [13]: a Out[13]: [1, 2, 3, 4, 5]]]></description>
</item><item>
    <title>Python, Objects, and some more..</title>
    <link>https://arvimal.github.io/posts/2016/10/2016-10-20-python-objects-and-some-more/</link>
    <pubDate>Thu, 20 Oct 2016 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2016/10/2016-10-20-python-objects-and-some-more/</guid>
    <description><![CDATA[_E_verything in Python is an object, what does that mean? This post tries to discuss some very basic concepts.
What does the following assignment do?
[code language=&ldquo;python&rdquo;]
a = 1 [/code] Of course, anyone dabbled in code knows this. The statement above creates a container `a` and stores the value `1` in it.
But it seem that&rsquo;s not exactly what&rsquo;s happening, at least from Python&rsquo;s view-point.
When a = 1 is entered or executed by the python interpreter, the following happens in the backend, seemingly unknown to the user.]]></description>
</item><item>
    <title>Max file-name length in an EXT4 file system.</title>
    <link>https://arvimal.github.io/posts/2016/07/2016-07-21-max-file-name-length-in-an-ext4-file-system/</link>
    <pubDate>Thu, 21 Jul 2016 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2016/07/2016-07-21-max-file-name-length-in-an-ext4-file-system/</guid>
    <description><![CDATA[A recent discussion at work brought up the question &ldquo;What can be the length of a file name in EXT4&rdquo;. Or in other words, what would be the maximum character length of the name for a file in EXT4?
Wikipedia states that it&rsquo;s 255 Bytes, but how does that come to be? Is it 255 Bytes or 255 characters?
In the kernel source for the 2.6 kernel series (the question was for a RHEL6/EXT4 combination), in fs/ext4/ext4.]]></description>
</item><item>
    <title>Inheritance and super() - Object Oriented Programming</title>
    <link>https://arvimal.github.io/posts/2016/07/2016-07-01-inheritance-and-super-object-oriented-programming/</link>
    <pubDate>Fri, 01 Jul 2016 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://arvimal.github.io/posts/2016/07/2016-07-01-inheritance-and-super-object-oriented-programming/</guid>
    <description><![CDATA[_s_uper() is a feature through which inherited methods can be accessed, which has been overridden in a class. It can also help with the MRO lookup order in case of multiple inheritance. This may not be obvious first, but a few examples should help to drive the point home.
Inheritance and method overloading was discussed in a previous post, where we saw how inherited methods can be overloaded or enhanced in the child classes.]]></description>
</item></channel>
</rss>
